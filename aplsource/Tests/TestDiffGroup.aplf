 TestDiffGroup;config;consumerA;consumerB;start;consumed_msgsA;cr;consumed_msgsB;_;producer;produced_msgs;msgs;i;t_consumed_msgsA;s_consumed_msgsA;t_consumed_msgsB;s_consumed_msgsB;t_produced_msgs;s_produced_msgs
⍝ Produce 15 msgs on topic1 and 20 on topic2
⍝ Consume all the msgs in the queue from two consumers
⍝ and check that each consumers consumes the produced
⍝ msgs and that they are the same and
⍝ in the same order within keys.

 #.Init'.'

⍝ Consumer configurations
 config←0 2⍴⍬
 config⍪←'bootstrap.servers' 'localhost:9092'
 config⍪←'client.id' 'consumerAclient'
 config⍪←'group.id' 'consumerAgroup'
 config⍪←'auto.offset.reset' 'earliest'
 ⎕←'Init new consumerA with config:'
 config

⍝ Init new Consumer
 consumerA←⎕NEW #.Consumer config


⍝ Consumer configurations
 config←0 2⍴⍬
 config⍪←'bootstrap.servers' 'localhost:9092'
 config⍪←'client.id' 'consumerBclient'
 config⍪←'group.id' 'consumerBgroup'
 config⍪←'auto.offset.reset' 'earliest'
 ⎕←'Init new consumerA with config:'
 config

⍝ Init new Consumer
 consumerB←⎕NEW #.Consumer config

⍝ Subscribe consumer to topic
 ⎕←'Subscribe consumers to topics "topic1" and "topic2":'
 consumerA.subscribe'topic1' 'topic2'
 consumerB.subscribe'topic1' 'topic2'
 ⎕←'Waiting for rebalance before starting consuming...'
 ⎕DL 5

 ⎕←'Consume the queueA before producing:'
 start←3⊃⎕AI
 consumed_msgsA←⍬
 :While 1
     cr←consumerA.consume_record
     :If 1=⊃cr
     :AndIf 20000>(3⊃⎕AI)-start
         :Continue
     :ElseIf 0=⊃cr
         _←⊂(2⊃cr).(Topic Payload Key Partition)
         start←0
     :Else
         cr
         :Leave
     :EndIf
 :EndWhile

 ⎕←'Consume the queueB before producing:'
 start←3⊃⎕AI
 consumed_msgsB←⍬
 :While 1
     cr←consumerB.consume_record
     :If 1=⊃cr
     :AndIf 20000>(3⊃⎕AI)-start
         :Continue
     :ElseIf 0=⊃cr
         _←⊂(2⊃cr).(Topic Payload Key Partition)
         start←0
     :Else
         cr
         :Leave
     :EndIf
 :EndWhile

 ⍝ Producer configurations
 config←0 2⍴⍬
 config⍪←'bootstrap.servers' 'localhost:9092'
 config⍪←'client.id' 'producerclient'
 ⎕←'Init new producer with config:'
 config

⍝ Init new Producer
 producer←⎕NEW #.Producer config

⍝ Produce bundled messages on topic and ask for dr
 ⎕←'Produce messages on topic1:'
 produced_msgs←⍬
 :For i :In ⍳15
     msgs←'topic1'('payload',⍕i)('key',⍕5|i)
     producer.produce_record ⎕NEW #.Record(msgs)
     produced_msgs,←⊂msgs
     :If 0=10|i
         ⎕←'Outstanding messages:'
         ⎕DL 0.5
         producer.update_outstanding
     :EndIf
 :EndFor
 ⎕←'Outstanding messages:'
 ⎕DL 0.5
 producer.update_outstanding

 ⎕←'Produce messages on topic2:'
 :For i :In ⍳20
     msgs←'topic2'('payload',⍕i)('key',⍕5|i)
     producer.produce_record ⎕NEW #.Record(msgs)
     produced_msgs,←⊂msgs
     :If 0=10|i
         ⎕←'Outstanding messages:'
         ⎕DL 0.5
         producer.update_outstanding
     :EndIf
 :EndFor

 ⎕←'Close producer:'
 ⎕EX'producer'

 ⎕←'ConsumerA consumes the testing queue:'
 start←3⊃⎕AI
 consumed_msgsA←⍬
 :While 1
     cr←consumerA.consume_record
     :If 1=⊃cr
     :AndIf 20000>(3⊃⎕AI)-start
         :Continue
     :ElseIf 0=⊃cr
         consumed_msgsA,←⊂(2⊃cr).(Topic Payload Key Partition)
         start←0
     :Else
         cr
         :Leave
     :EndIf
 :EndWhile

 ⎕←'ConsumerB consumes the testing queue:'
 start←3⊃⎕AI
 consumed_msgsB←⍬
 :While 1
     cr←consumerB.consume_record
     :If 1=⊃cr
     :AndIf 20000>(3⊃⎕AI)-start
         :Continue
     :ElseIf 0=⊃cr
         consumed_msgsB,←⊂(2⊃cr).(Topic Payload Key Partition)
         start←0
     :Else
         cr
         :Leave
     :EndIf
 :EndWhile


 ⎕←'Close consumerA and consumerB:'
 ⎕EX'consumerA'
 ⎕EX'consumerB'

 ⍝ Sort first by topic and then by key. The order is guaranteed in key
 t_consumed_msgsA←1{⍵[⍋⍵[;⍺];]}↑¯1↓¨consumed_msgsA
 s_consumed_msgsA←3{⍵[⍋⍵[;⍺];]}t_consumed_msgsA
 t_consumed_msgsB←1{⍵[⍋⍵[;⍺];]}↑¯1↓¨consumed_msgsB
 s_consumed_msgsB←3{⍵[⍋⍵[;⍺];]}t_consumed_msgsB


 t_produced_msgs←1{⍵[⍋⍵[;⍺];]}↑produced_msgs
 s_produced_msgs←3{⍵[⍋⍵[;⍺];]}t_produced_msgs


 'Produced and consumed messages from two different consumer groups'ASSERT(s_consumed_msgsB≡s_produced_msgs)∧s_consumed_msgsA≡s_produced_msgs
